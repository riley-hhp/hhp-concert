## 1. Redis를 이용한 캐시 적용
   ### 1.1 캐시 적용의 필요성
    
웹 애플리케이션에서는 데이터를 자주 조회하고, 그에 따라 DB에 부담이 발생하는 경우가 많습니다. 
특히 자주 조회되는 데이터나 변경되지 않는 데이터는 DB를 매번 조회하는 것보다 캐시를 활용하는 것이 효율적입니다. 
Redis는 메모리 기반의 데이터 저장소로, 빠른 데이터 처리와 적은 지연 시간 덕분에 캐시를 구현하는 데 최적화된 도구입니다.

### 1.2 캐시 기준점

Redis 캐시 적용의 기준점은 다음과 같습니다:

    1.	조회 빈도가 높은 데이터: 예를 들어, 콘서트 정보나 좌석 정보와 같이 자주 조회되지만 자주 변경되지 않는 데이터는 캐시를 적용하는 것이 유리합니다. 이렇게 하면 DB에 대한 반복적인 조회를 줄이고, 응답 속도를 개선할 수 있습니다.(캐시 적용)
    2.	데이터 변경이 빈번하지 않은 경우: 예를 들어, 대기열 순서나 사용자 토큰 상태와 같이 자주 변경되지 않는 정보는 캐시를 통해 빠르게 조회할 수 있습니다. 이러한 데이터는 캐시에서 조회하고, 만약 캐시가 만료되거나 존재하지 않으면 DB에서 새로 조회하는 방식으로 처리할 수 있습니다.(대기열 구현)
    3.	성능 향상 요구: 캐시를 사용하는 주된 이유는 DB의 부하를 줄이고 시스템 전체의 성능을 향상시키기 위함입니다. 자주 조회되는 데이터를 Redis 캐시로 처리함으로써 응답 속도를 크게 개선할 수 있습니다.

### 1.3 캐시 설정
캐시를 설정할 때, 기본적으로 @Cacheable과 @CacheEvict를 활용하여 데이터를 캐시하고 필요할 때 삭제할 수 있습니다. 
예를 들어, 콘서트 정보와 좌석 정보를 캐시할 때 아래와 같은 설정을 사용할 수 있습니다.

```java
    // 예약 가능 날짜 조회 
    @Cacheable(value = "concerts", key = "#concertId")
    public List<ConcertItem> getAvailableDates(long concertId) {

        return concertRepository.findAvailableConcertItems(concertId);
    }

    // 좌석 조회 
    @Cacheable(value = "seats", key = "#concertItemId")
    public List<Seat> getAvailableSeats(long concertItemId) {

        return concertRepository.findAvailableSeats(concertItemId);
    }
```

이처럼 캐시를 적용하면, concertId나 concertItemId에 해당하는 값은 Redis 캐시에서 조회되며, 캐시가 존재하지 않으면 DB에서 데이터를 조회한 후 캐시합니다.

### 1.4 캐시 만료와 TTL 설정
캐시 데이터를 저장할 때는 TTL(Time To Live) 값을 설정하여 캐시가 일정 시간 후 만료되도록 할 수 있습니다. 
만약 일정 기간이 지난 후에는 데이터가 최신 상태인지 확인해야 한다면 TTL을 적절하게 설정하는 것이 중요합니다.

## 2. Redis를 이용한 대기열 관리

### 2.1 대기열 관리의 필요성
특히 대규모 서비스에서는 대기열을 관리하는 것이 매우 중요합니다. 
예를 들어, 콘서트 좌석 예약 시스템에서는 수천 명 이상의 사용자가 동시에 예약을 시도할 수 있으며, 이때 시스템의 성능을 유지하려면 적절한 대기열 관리가 필요합니다. 
Redis는 고성능의 자료구조를 제공하며, 대기열 관리를 효과적으로 할 수 있습니다.

### 2.2 대기열 구현
Redis에서는 Sorted Set 자료구조를 이용하여 대기열을 관리하는 것이 매우 유용합니다. 
대기번호를 관리하는 데 Sorted Set을 사용하면, 각 사용자의 대기 순서를 자연스럽게 관리할 수 있습니다. 
예를 들어, 각 사용자가 대기 번호를 가지고 대기열에 진입할 때, Sorted Set의 score로 대기시간을 기록할 수 있습니다.

```java
String token = "user_token";
double score = System.currentTimeMillis();  // 현재 시간으로 대기시간 설정

redisTemplate.opsForZSet().add("waiting_queue", token, score);
```
이렇게 하면 각 사용자는 대기시간을 기준으로 Sorted Set에 순차적으로 추가됩니다. 
이후 대기순번을 관리하고, 사용자가 대기열에서 이동할 때마다 Sorted Set의 순서가 자동으로 갱신됩니다.


## 3. 시리얼라이즈 방식 고민

Redis에 데이터를 저장할 때, 데이터를 **직렬화(Serialize)**하는 방식은 매우 중요한 요소입니다. 
Redis는 문자열 데이터를 주로 처리하지만, 복잡한 객체를 저장할 때는 시리얼라이저가 필요합니다. 
주로 사용되는 시리얼라이저로는 JSON 직렬화와 직렬화된 바이너리 객체 방식이 있습니다.

	1.	JSON 직렬화: Jackson2JsonRedisSerializer 또는 GenericJackson2JsonRedisSerializer를 사용하여 객체를 JSON 형식으로 직렬화하여 저장합니다. 이 방식은 직관적이고 사람이 읽을 수 있는 형식으로 데이터를 저장할 수 있기 때문에 디버깅이 용이합니다.

	2.	직렬화된 바이너리 객체: Java 객체를 직렬화하여 바이너리 형식으로 저장하는 방식입니다. 이 방식은 성능적으로 유리할 수 있지만, 사람이 읽을 수 없으므로 디버깅 시 어려울 수 있습니다.


JSON 직렬화 방식은 객체 구조를 쉽게 파악할 수 있으며, 데이터 변경 시에도 유연하게 처리할 수 있습니다. 
또한, Redis에 저장된 데이터를 사람이 쉽게 읽을 수 있기 때문에 운영 및 디버깅에 유리합니다.
성능과 직관성을 고려하여, JSON 직렬화 방식을 추천합니다.

## 정리
Redis를 활용한 캐시 적용과 대기열 관리는 성능 개선에 유효합니다. 
캐시를 통해 DB의 부하를 줄이고, 대기열을 효율적으로 관리하여 예약 시스템의 성능을 최적화할 수 있습니다. 
Redis는 고성능의 자료구조와 빠른 응답 속도를 제공하여 대규모 서비스에서 필수적인 도구로 자리잡고 있습니다.
현업에서의 요구에 맞춰 실무적인 성능 최적화 기술을 꾸준히 익혀나가며, 더 나은 시스템을 구현하기 위한 노력을 계속해 나가야겠습니다.